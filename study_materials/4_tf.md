# Переходим к лидару

## Содержание

- [Содержание](#содержание)
- [Всё начинается с лидара](#всё-начинается-с-лидара)
- [Попытка отобразить исходную информацию из лидара - не пытка](#попытка-отобразить-исходную-информацию-из-лидара---не-пытка)
- [TF 101](#tf-101)
- [TF - всё относительно](#tf---всё-относительно)
- [Бооольше инструментов](#бооольше-инструментов)
  - [rqt\_tf\_tree](#rqt_tf_tree)
  - [tf\_echo](#tf_echo)
- [TF из Gazebo](#tf-из-gazebo)
- [Настройка Rviz](#настройка-rviz)
- [Чему научились?](#чему-научились)
- [Задание](#задание)
- [Вопросики](#вопросики)
- [Ресурсы](#ресурсы)
  - [Стандарты](#стандарты)


## Всё начинается с системы координат

Мы с тобой уже научились запускать симулятор и организовывать запуск необходимых узлов и других launch как нам надо.

А ещё и аргументы добавлять, чтобы делать удобное управление запуском!

Это уже хорошие навыки, но давай теперь начнём осваивать каждую часть набора программ (узлов), которые позволяют роботу двигаться к цели!

Начтем мы с системы коодинат робота.

## Попытка отобразить информацию о роботе

Давай запустим наш launch, который стартует симуляцию:

```bash
roslaunch panda_moveit_config demo.launch rviz_tutorial:=false use_rviz:=false
```

> Внимательный читатель заметил, что мы передали значение `false` аргументу `use_rviz`, тем самым отключив RViz, но это не просто так =)

Далее запустим в другом терминале окно Rviz

```bash
rviz
```

Настроим отображение - в окне `Displays` при помощи опции `Add` добавим отображение системы координат `TF` и `RobotModel`

Настриваем и уже видим странную проблему:

<p align="center">
    <img src=../assets/ros_topics/4_rviz_issue.png />
</p>

Давай посмотрим на первую ошибку, в "Global Status" ошибка "Unknown frame map". Это, обычно, происходит, если в "Global Options" -> "Fixed Frame" выбран несуществующий **фрейм**.

Что такое **фрейм** - чуть позже разберём, а пока выбери в Global Options -> Fixed Frame, например, `panda_link0`.

О, в "Global Status" теперь "OK"!

Ну, поехали, узнаем, про какие *фреймы* идёт речь и почему они так нужны для Rviz!

## TF 101

TF - это очень удобная система в ROS, которая позволяет работать с системами координат (СК) в пространстве. Принято считать, что TF - это сокращение от "transform". То есть, эта система организует трансформацию между СК.

Например, в руке есть плечо, локоть и кисть, у каждой части есть своё положение в пространстве. Мы знаем, что расстояние от плеча до локтя не меняется, как и расстояние от локтя до кисти. Получается, у нас есть СК в плече, локте и кисти. Между плечом и локтём 30 см и между кистью и локтём 30 см. Вот так мы описали относительное положение между СК!

Сначала прямую руку прижмём к туловищу, рука идёт вниз. Допустим, ось Z идет наверх, X - прямо, Y - влево. Если у плеча `X=0, Y=0, Z=0`, то у локтя будет порядка -0.3 м по Z, а у кисти около -0.6 м. Всё остальное по нулям (`X=0, Y=0`).

Теперь поднимем прямую руку ровно наверх, Z локтя и кисти будут иметь те же значения, но положительные. Тут всё просто, так?

А теперь фокус, плечо сгибаем около 65 градусов, локоть на 35 градусов, какие координаты будут у локтя и кисти?

Если ты очень хорошо помнишь тригонометрию и принципы поворотов систем координат, то тебе не составит труда посчитать.

Дать время подумать? =)

Эта математика расчёта уже давно реализована и как раз TF позволяет нам не беспокоиться о том, что и как надо делать в плане расчётов!

Мы описываем отношения между системами координат (СК) и после этого, построив цепочку из СК, можем относительно одной получать информацию об остальных!

Это очень удобно! Но к чему слова? Нам же надо разобраться с проблемой отображения данных в Rviz, что он хочет?

Во-первых, термин **фрейм** в Rviz - это просто система координат. Тут всё просто.

Во-вторых, что за фрейм `panda_link0` он хочет? Тут сложнее, но интереснее!

Приводные механизмы робота выдают нам информацию о своем положении (угле, на который они отклонены), что дает информацию о попарном взаиморасположении отдельных частей робота.

Но чтобы их отобразить, Rviz надо знать, относительно чего рисовать. Ведь все привода где-то располагаются на нашем роботе, а значит, надо сообщить Rviz, относительно каких точек они последовательно соединены.

Для этого мы сообщим системе, как располагается `panda_link0` относительно `panda_link1`, `panda_link1` относительно `panda_link2` и так далее. `panda_link0` в данном случае выступает точкой основания робота, контактирующей с опорой (высота = 0).

Чтобы сообщить о том, насколько высоко располагаются остальные сочленения относительно пола, добавим запуск узла, который создаёт **статический TF** между фреймами. Создадим новый launch в пакете c названием `panda_tf.launch`:

```xml
<node pkg="tf" type="static_transform_publisher" name="map_2_panda_link0" args="0 0 0 0 0 0 map panda_link0" />
```

> Не забудь, что `<launch>` тэг должен обрамлять весь файл, то есть добавлять надо внутрь него!

Тут мы немного цепляем запуск узлов в launch-файла. Чтобы опубликовать статический TF (сообщить расположение `panda_link0` относительно `map`), нам нужно запустить узел `static_transform_publisher` из пакета [tf2_ros](http://wiki.ros.org/tf2_ros).

Чтобы это сделать мы прописываем в атрибутах тэга `<node>`:

- `pkg` - название пакета, из которого запускаем,
- `type` - название узла, который в пакете надо запустить,
- `name` - как узел будет называться в системе,
- `args` - аргументы узла.

Аргументы у static_transform_publisher узла следующие `x y z yaw pitch roll frame_id child_frame_id`. Разберём:

- `x, y, z` - линейное расположение `child_frame_id` относительно `frame_id`,
- `yaw pitch roll` - угловое расположение (поворот) `child_frame_id` относительно `frame_id`,
- `frame_id child_frame_id` - имена фрейма, между которыми создаём TF,

Такс, ну мы много тут всего написали, но главное, что нам теперь надо вернуться к Rviz и посмотреть, помогло ли это отобразить данные о положении робота:

Перезапускаем лаунч с симуляцией робота

```bash
roslaunch panda_moveit_config demo.launch rviz_tutorial:=false use_rviz:=false
```

Запускаем публикацию преобразования в систему координат TF

```bash
roslaunch study_pkg panda_tf.launch
```

Запустим Rviz, вернем прежную настройку отображения и увидим, что все данные отображаются корректно! Отлично!

<p align="center">
    <img src=../assets/ros_topics/4_rviz_success.png />
</p>

Мы смогли починить недостающую информацию для отображения данных с лидара! В системе не хватало информации о том, как расположен `panda_link0` фрейм относительно `map`!

> Попробуй поменять значения `x, y, z, yaw pitch roll` в аргументах TF узла и перезапускать после изменений launch с этим узлом. Посмотри, как это влияет на отображение.

## TF - всё относительно

Результат есть, круто, но не складывается ли ощущение, что мы просто угадали и всё сделали правильно? Ведь, если разбираешься с каким-нибудь инструментом, всегда нужно чётко осознавать, что, как и почему делается!

Во-первых, важно сейчас понять, что СК не существует сама по себе! Именно поэтому мы описываем не расположения фреймов самих по себе, а именно относительное расположение между ними. Так, чтобы отобразить, мы задаём базовый фрейм (Fixed Frame), относительно которого всё и рисуется.

Давай отобразим фреймы в Rviz, чтобы увидеть, как они расположены! `Add` -> `By display type` -> `TF`:

<p align="center">
    <img src=../assets/ros_topics/4_rviz_tf_frames.png />
</p>

Так ведь удобнее, правда?

> А теперь попробуй поперемещать робота при помощи плагина MotionPlanning и скажи, какие из TF (TF - это соотношение между фреймами) являются **статическими**, а каким **динамическими**?

Мы пока не объясняли эти термины, но думаю, тут уже понятно, в чём разница =)

**Статический TF** (`world` -> `panda_link0`) - положение между фреймами не меняются во времени (наш робот все время стоит в одной и той же точке).
**Динамический TF** (`panda_link0` -> `panda_link1`) - положение между фреймами может меняться во времени.

Почему не бывает динамического фрейма? Всё просто, например, фрейм `panda_link0` относится как к динамическому TF, так и к статическому TF. Нет однозначности в этой характеристике.

Так, прекрасно, мы освоили ещё немного терминов и смогли отрисовать TF в Rviz, чтобы проще было ориентироваться! Отличный результат!

## Бооольше инструментов

Сейчас всё идет по плану, но часто в ходе разработки или отладки системы происходят проблемы и всплывают баги настройки, ой как часто...

Более того, мы смогли отобразить TF в Rviz, но в нём не понятно, как увидеть соотношение между фреймами и более того, численных значений преобразований (TF) между фреймами!

Значит, сейчас пока мы не можем в полной мере понять, что происходит внутри системы - погнали осваивать инструменты!

### rqt_tf_tree

Первый инструмент поможет нам понять, как соотносятся между собой фреймы и кто является источником информации о TF - `rqt_tf_tree`!

Просто стартуем:

```bash
rosrun rqt_tf_tree rqt_tf_tree
```

И вот мы видим простой и приятный интерфейс:

<p align="center">
    <img src=../assets/ros_topics/4_rqt_tf_tree.png />
</p>

В этом интерфейсе мы видим, как фреймы зависимы!

> Важно, правильное дерево имеет формат **дерева**, то есть у нижестоящих фреймов не может быть два родителя или стрелочки не могут идти наверх!

С помощью этого инструмента можно понять, как взаимосвязаны фреймы и есть ли ошибки в построении дерева TF, так как на этом достаточно часто происходят ошибки.

### tf_echo

Другой инструмент позволит нам понять численные характеристики той или иной TF - `tf_echo`.

```bash
rosrun tf tf_echo world panda_link0
```

И вот результат:

```
At time 0.000
- Translation: [0.000, 0.000, 0.000]
- Rotation: in Quaternion [0.000, 0.000, 0.000, 1.000]
            in RPY (radian) [0.000, -0.000, 0.000]
            in RPY (degree) [0.000, -0.000, 0.000]
At time 0.000
- Translation: [0.000, 0.000, 0.000]
- Rotation: in Quaternion [0.000, 0.000, 0.000, 1.000]
            in RPY (radian) [0.000, -0.000, 0.000]
            in RPY (degree) [0.000, -0.000, 0.000]
```

Как видно, статическая TF не меняется - логично! =)

> Отобрази TF "panda_link0 -> panda_link1". Посмотри значения между ними.

> Разберись, как в tf_echo задать частоту отображения данных

Отлично! Вот у нас и получилось понять соотношение между фреймами, а также получить информацию о конкретном TF в численном виде, а не "на глаз"!

## Настройка Rviz

Такс, не спешим, у нас осталась одна нерешённая проблемка...

Мы тут перезапустили Rviz и приходится каждый раз настраивать! Это же уйма времени будет потрачена! Не годится.

Давай посмотрим `rviz -h` и найдём ооочень полезную строку:

```bash
-d [ --display-config ] arg A display config file (.rviz) to load
```

То есть, в rviz есть опция, которая позволяет подгрузить конфигурацию отображения из файла? Хм, это может быть полезно!

Закончи настройку отображения информации как тебе хочется (может точки больше сделаешь?) и жмём кнопку `File`->"`Save Config As`" (сверху слева):

<p align="center">
    <img src=../assets/ros_topics/4_rviz_file_button_pos.png />
</p>

> Не нажимай "Save Config" или сочетание "Ctrl+S", так как это сохранит нынешнее отображение как настройки по-умолчанию!

В окне сохранения пройди в папку пакета и там создай папку `rviz` и туда сохрани в файл под названием `panda_rviz.rviz`.

> Для дальшейней работы создай в папке `launch` файл с названием `panda_rviz.launch` и помести в него следующее содержимое

```xml
<node name="rviz" pkg="rviz" type="rviz" args="-d $(find study_pkg)/rviz/panda_rviz.rviz" />
```

> Не забудь, что `<launch>` тэг должен обрамлять весь файл, то есть добавлять надо внутрь него!

Добавил? Отлично, перезапускай!

Всё на месте! Теперь тебе не придется каждый раз настраивать Rviz! А ещё тут есть приятный сорприз, если поменять что-либо в отображении и нажать "Ctrl+S", то это сохранится и в следующем запуске будет тут же! Шикарно!

А всего-то поняли, что есть проблема и в два счёта решили ее, проверив help!

> ! Практика показывает, что создание rviz конфигураций под каждую задачу является удобным способом хранения. Не пытайтесь держать одну конфигурацию под все задачи, например, "проверка работы модели в симуляторе", "отображение данных с камеры", "отображения инфы от робота" и т.д.

## Чему научились?

- Настройка Rviz
- Ознакомились с понятием TF и её удобствами
- Смогли сделать статическую публикацию TF в launch
- Научились отображать TF в Rviz
- Освоили инструменты `rqt_tf_tree` и `tf_echo`

## Задание

- Попробуй отобразить другую информацию в Rviz - теперь ты это умеешь! Посмотри, что происходит с остальными фреймами при движении.
- Посмотри значения TF между разными фреймами, все ли значения понятны?


## Вопросики

- В чём разница статических и динамических TF?
- Почему фрейм нельзя характеризовать статическим/динамическим?
- Как сохранить настройку Rviz? Как её восстановить?
- \* Что такое кватернион?

## Ресурсы

- [Хорошая статья с примером описания основных фреймов робота](http://wiki.ros.org/hector_slam/Tutorials/SettingUpForYourRobot)

### Стандарты

Вообще, это просто два основных стандарта касательно фреймов и TF, но мы очень рекомендуем их почитать:

- [REP-105](https://www.ros.org/reps/rep-0105.html) - описание основных фреймов;
- [REP-103](https://www.ros.org/reps/rep-0103.html) - описание основных единиц измерения и координатных преобразований.
