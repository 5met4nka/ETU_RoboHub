#!/usr/bin/env python

# Python 2/3 compatibility imports
from __future__ import print_function
from six.moves import input

import sys
import copy
import rospy
import moveit_commander
import moveit_msgs.msg
import geometry_msgs.msg

try:
    from math import pi, tau, dist, fabs, cos
except:  # For Python 2 compatibility
    from math import pi, fabs, cos, sqrt

    tau = 2.0 * pi

    def dist(p, q):
        return sqrt(sum((p_i - q_i) ** 2.0 for p_i, q_i in zip(p, q)))


from std_msgs.msg import String
from moveit_commander.conversions import pose_to_list


def all_close(goal, actual, tolerance):
    """
    Утилитарная функция для проверки, находятся ли значения из двух списков в пределах указанной допустимой погрешности.
    Для входных данных типа Pose и PoseStamped сравнивается угол между двумя кватернионами
    (угол между одинаковыми ориентациями q и -q рассчитывается корректно).

    @param goal: Список чисел с плавающей точкой, объект Pose или объект PoseStamped.
                 Это целевое значение, с которым сравнивается "actual".
    @param actual: Список чисел с плавающей точкой, объект Pose или объект PoseStamped.
                   Это фактическое значение, которое сравнивается с "goal".
    @param tolerance: Число с плавающей точкой, представляющее допустимую погрешность.
    @returns: Логическое значение (bool): True, если значения соответствуют заданной точности; иначе False.
    """

    # Если цель и фактические значения представлены в виде списка чисел:
    if type(goal) is list:
        # Проверяем каждый элемент списка. Если разница превышает допустимую погрешность, возвращаем False.
        for index in range(len(goal)):
            if abs(actual[index] - goal[index]) > tolerance:
                return False

    # Если цель и фактические значения представлены в виде объектов PoseStamped:
    elif type(goal) is geometry_msgs.msg.PoseStamped:
        # Рекурсивно вызываем эту функцию, передавая pose части объектов PoseStamped для сравнения.
        return all_close(goal.pose, actual.pose, tolerance)

    # Если цель и фактические значения представлены в виде объектов Pose:
    elif type(goal) is geometry_msgs.msg.Pose:
        # Преобразуем объекты Pose в списки координат (позиция и ориентация в формате кватернионов).
        x0, y0, z0, qx0, qy0, qz0, qw0 = pose_to_list(actual)
        x1, y1, z1, qx1, qy1, qz1, qw1 = pose_to_list(goal)
        
        # Рассчитываем Евклидово расстояние между точками в 3D-пространстве.
        d = dist((x1, y1, z1), (x0, y0, z0))
        
        # Рассчитываем угол между ориентациями (косинус половинного угла между кватернионами).
        cos_phi_half = fabs(qx0 * qx1 + qy0 * qy1 + qz0 * qz1 + qw0 * qw1)
        
        # Проверяем два условия:
        # 1. Евклидово расстояние между позициями должно быть меньше или равно допустимой погрешности.
        # 2. Косинус половинного угла должен быть больше или равен косинусу половины допустимого угла.
        return d <= tolerance and cos_phi_half >= cos(tolerance / 2.0)

    # Если ни одно из условий выше не выполнено (неизвестный тип данных), возвращаем True.
    return True


class MoveGroupPythonInterfaceTutorial(object):
    """Класс для управления роботом с использованием MoveIt! и Move Group интерфейса.
    Предназначен для демонстрации базового функционала MoveIt! в Python."""

    def __init__(self):
        super(MoveGroupPythonInterfaceTutorial, self).__init__()

        ## Инициализация MoveIt! Commander и ROS-ноды:
        # MoveIt! Commander управляет роботами, группами и сценой с помощью MoveIt API.
        # rospy используется для взаимодействия с ROS-системой.
        moveit_commander.roscpp_initialize(sys.argv)
        rospy.init_node("move_group_python_interface_tutorial", anonymous=True)

        # Создание объекта `RobotCommander`, который предоставляет информацию
        # о кинематической модели робота и текущих состояниях его сочленений (joint states).
        robot = moveit_commander.RobotCommander()

        # Создание объекта `PlanningSceneInterface`, который предоставляет интерфейс
        # для взаимодействия с планировочной сценой, включая добавление и удаление объектов.
        scene = moveit_commander.PlanningSceneInterface()

        # Создание объекта `MoveGroupCommander`, который управляет группой суставов.
        # В этом примере группа суставов именуется "panda_arm".
        # Для другого робота необходимо указать соответствующую группу.
        group_name = "panda_arm"  # Название группы планирования для робота.
        move_group = moveit_commander.MoveGroupCommander(group_name)

        # Создание ROS-публишера для отображения траекторий в Rviz.
        # Это позволяет визуализировать спланированные траектории.
        display_trajectory_publisher = rospy.Publisher(
            "/move_group/display_planned_path",  # Топик для публикации траекторий.
            moveit_msgs.msg.DisplayTrajectory,   # Тип сообщения для отображения траекторий.
            queue_size=20                        # Размер очереди сообщений.
        )

        ## Получение базовой информации о роботе
        ##
        # Получение системы координат (reference frame), используемой для планирования движений:
        planning_frame = move_group.get_planning_frame()
        print("============ Planning frame: %s" % planning_frame)

        # Получение имени звена манипулятора, отвечающего за взаимодействие с объектами:
        eef_link = move_group.get_end_effector_link()
        print("============ End effector link: %s" % eef_link)

        # Получение списка всех доступных групп планирования у робота:
        group_names = robot.get_group_names()
        print("============ Available Planning Groups:", robot.get_group_names())

        # Вывод текущего состояния робота для отладки:
        print("============ Printing robot state")
        print(robot.get_current_state())  # Печатает полное состояние робота.
        print("")

        # Прочие переменные
        # Инициализация переменных для хранения информации о сцене и роботах.
        self.box_name = ""  # Имя объекта, добавленного в сцену.
        self.robot = robot  # Экземпляр RobotCommander.
        self.scene = scene  # Экземпляр PlanningSceneInterface.
        self.move_group = move_group  # Экземпляр MoveGroupCommander.
        self.display_trajectory_publisher = display_trajectory_publisher  # Публишер для отображения траекторий.
        self.planning_frame = planning_frame  # Система координат планирования.
        self.eef_link = eef_link  # Звено конечного эффектора.
        self.group_names = group_names  # Список групп планирования.

    def go_to_joint_state(self):
        """
        Функция для перемещения робота в заданное состояние суставов (joint state).
        Используется MoveIt для планирования и выполнения движения робота.

        @return: True, если конечное состояние робота близко к заданному (в пределах погрешности 0.01).
        """

        # Локальная копия объекта управления Move Group для упрощения понимания кода в веб-уроках.
        # На практике можно использовать self.move_group напрямую, если нет специфической причины иначе.
        move_group = self.move_group

        ##
        ## Планирование движения к заданным значениям суставов
        ## ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        ## Начальная конфигурация Panda-робота является сингулярной, поэтому первым шагом
        ## мы переводим его в более безопасное и удобное состояние.

        # Получаем текущие значения суставов (joint states) из Move Group.
        joint_goal = move_group.get_current_joint_values()

        # Устанавливаем целевые значения для суставов:
        joint_goal[0] = 0                     # Угол для первого сустава.
        joint_goal[1] = -tau / 8              # Угол для второго сустава (-π/4).
        joint_goal[2] = 0                     # Угол для третьего сустава.
        joint_goal[3] = -tau / 4              # Угол для четвертого сустава (-π/2).
        joint_goal[4] = 0                     # Угол для пятого сустава.
        joint_goal[5] = tau / 6               # Угол для шестого сустава (π/3).
        joint_goal[6] = 0                     # Угол для седьмого сустава.

        # Передаем целевые значения суставов в планировщик MoveIt.
        # Метод `go()` инициирует движение к заданным значениям.
        # Аргумент `wait=True` означает, что выполнение функции будет заблокировано
        # до завершения движения.
        move_group.go(joint_goal, wait=True)

        # Останавливаем любое остаточное движение робота, если оно есть.
        # Это полезно для предотвращения дрожания или незапланированного движения.
        move_group.stop()

        # Тестирование:
        # Получаем текущие значения суставов после выполнения движения.
        current_joints = move_group.get_current_joint_values()
        
        # Сравниваем текущие значения суставов с целевыми значениями.
        # Функция `all_close` проверяет, находятся ли значения в пределах заданной погрешности (0.01).
        return all_close(joint_goal, current_joints, 0.01)

    def go_to_pose_goal(self):
        """
        Функция для планирования и выполнения движения манипулятора к заданной целевой позе
        (позиции и ориентации) конечного эффектора.

        @return: True, если конечное состояние робота близко к целевой позе (в пределах погрешности 0.01).
        """

        # Локальная копия объекта управления Move Group для упрощения понимания кода в веб-уроках.
        # На практике можно использовать self.move_group напрямую, если нет специфической причины иначе.
        move_group = self.move_group
        ##
        ## Планирование движения к целевой позе
        ## ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        ## Можно спланировать движение этой группы суставов для достижения
        ## желаемой позы конечного эффектора (end-effector).

        # Создаем объект Pose, задающий целевую позу.
        pose_goal = geometry_msgs.msg.Pose()
        pose_goal.orientation.w = 1.0  # Кватернион для ориентации (ориентация без поворота).
        pose_goal.position.x = 0.4     # Координата x целевой позиции.
        pose_goal.position.y = 0.1     # Координата y целевой позиции.
        pose_goal.position.z = 0.4     # Координата z целевой позиции.

        # Устанавливаем целевую позу для Move Group.
        move_group.set_pose_target(pose_goal)

        # Планировщик рассчитывает траекторию и выполняет движение.
        # Метод `go()` возвращает True, если планирование и выполнение прошли успешно.
        success = move_group.go(wait=True)

        # Останавливаем остаточное движение, чтобы избежать дрожания или других неконтролируемых эффектов.
        move_group.stop()

        # Очищаем целевые позы после завершения движения.
        # Это рекомендуется делать после планирования с использованием целевых поз,
        # чтобы избежать конфликтов в последующих вызовах.
        move_group.clear_pose_targets()

        # Для тестирования:
        # Получаем текущую позу конечного эффектора.
        current_pose = self.move_group.get_current_pose().pose

        # Сравниваем текущую позу с целевой позой.
        # Функция `all_close` проверяет, находятся ли текущие значения в пределах заданной погрешности (0.01).
        return all_close(pose_goal, current_pose, 0.01)

    def plan_cartesian_path(self, scale=1):
        """
        Планирование траектории в декартовом пространстве для конечного эффектора.
        В этой функции задается последовательность промежуточных точек, которые должен пройти
        конечный эффектор, и рассчитывается соответствующая траектория.

        @param scale: Масштаб движения (умножается на каждое смещение для изменения амплитуды).
        @return: Кортеж (plan, fraction), где:
            - plan: Запланированная траектория.
            - fraction: Доля успешно интерполированных точек траектории (от 0 до 1).
        """

        # Локальная копия объекта управления Move Group для удобства.
        move_group = self.move_group

        ##
        ## Декартовы траектории
        ## ^^^^^^^^^^^^^^^^^^^^
        ## Можно планировать декартовую траекторию, задавая список промежуточных точек (waypoints),
        ## через которые должен пройти конечный эффектор.

        # Список промежуточных точек, которые нужно пройти.
        waypoints = []

        # Получаем текущую позу конечного эффектора.
        wpose = move_group.get_current_pose().pose

        # Первая точка: смещаем конечный эффектор вверх по оси z и в сторону по оси y.
        wpose.position.z -= scale * 0.1  # Подъем/опускание (z).
        wpose.position.y += scale * 0.2  # Смещение в сторону (y).
        waypoints.append(copy.deepcopy(wpose))  # Добавляем копию текущей позы в список.

        # Вторая точка: смещаем конечный эффектор вперед/назад по оси x.
        wpose.position.x += scale * 0.1  # Смещение вперед/назад (x).
        waypoints.append(copy.deepcopy(wpose))  # Добавляем копию текущей позы в список.

        # Третья точка: возвращаем конечный эффектор немного назад по оси y.
        wpose.position.y -= scale * 0.1  # Смещение в противоположную сторону (y).
        waypoints.append(copy.deepcopy(wpose))  # Добавляем копию текущей позы в список.

        # Планирование декартовой траектории:
        # compute_cartesian_path вычисляет траекторию, проходящую через указанные промежуточные точки.
        # eef_step (0.01) задает разрешение интерполяции (шаг 1 см).
        # jump_threshold (0.0) отключает проверку на недопустимые резкие изменения положения суставов.
        (plan, fraction) = move_group.compute_cartesian_path(
            waypoints,  # Список промежуточных точек.
            0.01,       # Шаг интерполяции в метрах.
            0.0         # Порог "прыжка" в пространстве суставов (отключен).
        )

        # Примечание: на данном этапе мы только планируем движение, а не выполняем его.
        return plan, fraction


    def display_trajectory(self, plan):
        """
        Функция для отображения запланированной траектории в Rviz.
        Использует ROS-публишер для публикации траектории, которая затем визуализируется в Rviz.

        @param plan: Запланированная траектория (объект, возвращаемый MoveIt).
        """

        # Локальные копии объектов для упрощения кода (опционально).
        robot = self.robot
        display_trajectory_publisher = self.display_trajectory_publisher

        ##
        ## Отображение траектории
        ## ^^^^^^^^^^^^^^^^^^^^^^
        ## Вы можете попросить Rviz визуализировать запланированную траекторию.
        ## Однако метод `group.plan()` делает это автоматически, поэтому эта функция
        ## полезна для явного повторного отображения траектории или когда визуализация
        ## требуется отдельно.

        # Создаем объект сообщения DisplayTrajectory, который предназначен
        # для отображения траектории в Rviz.
        display_trajectory = moveit_msgs.msg.DisplayTrajectory()

        # Поле trajectory_start заполняется текущим состоянием робота.
        # Это позволяет скопировать любые связанные объекты (например, захваченные объекты),
        # чтобы они также отображались корректно.
        display_trajectory.trajectory_start = robot.get_current_state()

        # Добавляем запланированную траекторию (plan) в список траекторий.
        display_trajectory.trajectory.append(plan)

        # Публикуем сообщение DisplayTrajectory в топик.
        # После публикации Rviz автоматически отображает траекторию.
        display_trajectory_publisher.publish(display_trajectory)


    def execute_plan(self, plan):
        """
        Функция для выполнения запланированной траектории роботом.
        Использует метод `execute()` для передачи роботу рассчитанного плана.

        @param plan: Запланированная траектория (объект RobotTrajectory, возвращаемый MoveIt).
        """

        # Локальная копия объекта управления Move Group для удобства (опционально).
        move_group = self.move_group

        ##
        ## Выполнение плана
        ## ^^^^^^^^^^^^^^^^^
        ## Используйте метод `execute()`, если хотите, чтобы робот следовал
        ## траектории, которая уже была рассчитана.

        # Выполняем план, передавая его в метод `execute`.
        # Аргумент `wait=True` означает, что выполнение функции будет заблокировано
        # до завершения выполнения всей траектории.
        move_group.execute(plan, wait=True)

        ## **Примечание:** Текущее состояние суставов робота должно находиться
        ## в пределах допустимой погрешности от первого waypoint в траектории.
        ## Если это условие не выполнено, выполнение `execute()` завершится ошибкой.

    def wait_for_state_update(self, box_is_known=False, box_is_attached=False, timeout=4):
        """
        Ожидает обновления состояния сцены, чтобы убедиться, что изменения (например,
        добавление, удаление, привязка или отвязка объектов) были корректно отражены в планировочной сцене.

        @param box_is_known: Логическое значение, указывающее, ожидается ли, что объект "box"
                            будет известен (существует в списке известных объектов).
        @param box_is_attached: Логическое значение, указывающее, ожидается ли, что объект "box"
                                будет прикреплен к роботу.
        @param timeout: Максимальное время ожидания обновления состояния (в секундах).
        @return: True, если обновление состояния было получено в пределах времени ожидания; иначе False.
        """

        # Локальная копия имени объекта и сцены для удобства.
        box_name = self.box_name
        scene = self.scene

        ##
        ## Убедитесь, что обновления сцены получены
        ## ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        ## Если Python-нода была только что создана или завершила работу до публикации
        ## обновлений сцены, сообщения могут быть утеряны, и объект "box" не появится.
        ## Чтобы гарантировать обновления, мы ожидаем, пока изменения не отразятся
        ## в списках ``get_attached_objects()`` и ``get_known_object_names()``.

        # Отслеживаем начальное время ожидания.
        start = rospy.get_time()
        seconds = rospy.get_time()

        # Цикл ожидания обновления состояния.
        while (seconds - start < timeout) and not rospy.is_shutdown():
            # Проверяем, прикреплен ли объект "box".
            attached_objects = scene.get_attached_objects([box_name])
            is_attached = len(attached_objects.keys()) > 0

            # Проверяем, известен ли объект "box" в сцене.
            # Если объект прикреплен, он будет удален из списка известных объектов.
            is_known = box_name in scene.get_known_object_names()

            # Проверяем, совпадает ли текущее состояние с ожидаемым.
            if (box_is_attached == is_attached) and (box_is_known == is_known):
                return True  # Состояние обновлено до ожидаемого.

            # Даем другим потокам время для выполнения и обновления.
            rospy.sleep(0.1)
            seconds = rospy.get_time()  # Обновляем текущее время.

        # Если цикл завершился без возврата, значит, время ожидания истекло.
        return False

    def add_box(self, timeout=4):
        """
        Функция для добавления объекта (коробки) в планировочную сцену.
        Объект создается в указанной позиции и добавляется с помощью интерфейса планировочной сцены.

        @param timeout: Максимальное время ожидания обновления состояния сцены (в секундах).
        @return: True, если объект успешно добавлен в сцену в течение указанного времени.
        """

        # Локальные копии переменных для удобства понимания в веб-уроках.
        # На практике можно использовать self.box_name и self.scene напрямую.
        box_name = self.box_name
        scene = self.scene

        ##
        ## Добавление объектов в планировочную сцену
        ## ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        ## Сначала создаем объект коробки в сцене. Коробка будет расположена
        ## в заданной позиции относительно фрейма "panda_hand".

        # Создаем объект PoseStamped для задания положения и ориентации коробки.
        box_pose = geometry_msgs.msg.PoseStamped()
        box_pose.header.frame_id = "panda_hand"  # Указываем, что положение задается относительно "panda_hand".
        box_pose.pose.orientation.w = 1.0       # Устанавливаем ориентацию без поворота (единичный кватернион).
        box_pose.pose.position.z = 0.11         # Задаем смещение по оси z (над "panda_hand").

        # Имя объекта коробки.
        box_name = "box"

        # Добавляем коробку в сцену с помощью метода `add_box`.
        # Указываем имя, позу и размеры коробки (0.075 x 0.075 x 0.075 м).
        scene.add_box(box_name, box_pose, size=(0.075, 0.075, 0.075))

        # Сохраняем имя коробки как атрибут класса.
        # На практике можно использовать self.box_name напрямую.
        self.box_name = box_name

        # Ждем, пока объект не будет добавлен в сцену, проверяя это с помощью функции wait_for_state_update.
        return self.wait_for_state_update(box_is_known=True, timeout=timeout)

    def attach_box(self, timeout=4):
        """
        Функция для прикрепления объекта (коробки) к конечному эффектору робота.
        Это позволяет роботу взаимодействовать с объектом (например, захватывать его),
        игнорируя столкновения между коробкой и частями захвата.

        @param timeout: Максимальное время ожидания обновления состояния сцены (в секундах).
        @return: True, если объект успешно прикреплен к роботу в течение указанного времени.
        """

        # Локальные копии переменных для удобства понимания.
        # На практике можно использовать атрибуты класса (self.box_name, self.robot и т. д.) напрямую.
        box_name = self.box_name  # Имя объекта (коробки), который нужно прикрепить.
        robot = self.robot        # Экземпляр RobotCommander для управления роботом.
        scene = self.scene        # Экземпляр PlanningSceneInterface для управления сценой.
        eef_link = self.eef_link  # Звено конечного эффектора, к которому будет прикреплен объект.
        group_names = self.group_names  # Список групп планирования для текущего робота.

        ##
        ## Прикрепление объектов к роботу
        ## ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        ## Следующим шагом будет прикрепление коробки к запястью робота.
        ## Для манипуляции объектами роботу нужно уметь касаться их, не вызывая
        ## ошибок столкновения. Чтобы игнорировать столкновения между коробкой и
        ## частями захвата, мы указываем звенья, которые можно "касаться" объекта
        ## в массиве ``touch_links``.

        # Имя группы захвата. Для Panda-робота это "panda_hand".
        # Если используется другой робот, измените это имя на название группы
        # вашего конечного эффектора.
        grasping_group = "panda_hand"

        # Получаем список звеньев, связанных с группой захвата.
        # Эти звенья будут добавлены в массив `touch_links`, чтобы столкновения между
        # этими звеньями и коробкой игнорировались.
        touch_links = robot.get_link_names(group=grasping_group)

        # Прикрепляем объект к звену конечного эффектора (eef_link).
        # touch_links указывает звенья, которые могут касаться коробки без учета столкновений.
        scene.attach_box(eef_link, box_name, touch_links=touch_links)

        # Ожидаем обновления состояния сцены, чтобы убедиться, что объект успешно прикреплен.
        return self.wait_for_state_update(
            box_is_attached=True,  # Коробка должна быть прикреплена.
            box_is_known=False,    # Коробка больше не должна быть в списке известных объектов сцены.
            timeout=timeout        # Максимальное время ожидания (в секундах).
        )

    def detach_box(self, timeout=4):
        """
        Функция для отсоединения объекта (коробки) от конечного эффектора робота.
        После отсоединения объект больше не является прикрепленным к роботу, но остается
        известным объектом в сцене.

        @param timeout: Максимальное время ожидания обновления состояния сцены (в секундах).
        @return: True, если объект успешно отсоединен в течение указанного времени.
        """

        # Локальные копии переменных для удобства.
        box_name = self.box_name  # Имя объекта (коробки), который нужно отсоединить.
        scene = self.scene        # Экземпляр PlanningSceneInterface для управления сценой.
        eef_link = self.eef_link  # Звено конечного эффектора, от которого отсоединяется объект.

        ##
        ## Отсоединение объектов от робота
        ## ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        ## Вы можете отсоединить объект от конечного эффектора и вернуть его в планировочную сцену.

        # Удаляем объект из прикрепленных к звену конечного эффектора.
        # После этого объект становится "известным" в сцене, но уже не прикрепленным.
        scene.remove_attached_object(eef_link, name=box_name)

        # Ожидаем обновления состояния сцены, чтобы убедиться, что объект отсоединен.
        return self.wait_for_state_update(
            box_is_known=True,   # Объект должен стать известным (появится в списке известных объектов).
            box_is_attached=False,  # Объект больше не прикреплен.
            timeout=timeout      # Максимальное время ожидания.
        )


    def remove_box(self, timeout=4):
        """
        Функция для удаления объекта (коробки) из планировочной сцены.
        Перед удалением объект должен быть отсоединен от робота (если был прикреплен).

        @param timeout: Максимальное время ожидания обновления состояния сцены (в секундах).
        @return: True, если объект успешно удален из сцены в течение указанного времени.
        """

        # Локальные копии переменных для удобства.
        box_name = self.box_name  # Имя объекта (коробки), который нужно удалить.
        scene = self.scene        # Экземпляр PlanningSceneInterface для управления сценой.

        ##
        ## Удаление объектов из планировочной сцены
        ## ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        ## Вы можете удалить объект из мира (планировочной сцены).

        # Удаляем объект из мира.
        scene.remove_world_object(box_name)

        ## **Примечание:** Объект должен быть отсоединен, прежде чем он может быть удален.

        # Ожидаем обновления состояния сцены, чтобы убедиться, что объект удален.
        return self.wait_for_state_update(
            box_is_attached=False,  # Объект не должен быть прикреплен.
            box_is_known=False,     # Объект больше не должен быть известным в сцене.
            timeout=timeout         # Максимальное время ожидания.
        )

def main():
    """
    Главная функция, демонстрирующая использование интерфейса MoveIt MoveGroup с помощью Python.
    Последовательно выполняет различные задачи: движение робота, управление траекториями,
    взаимодействие с объектами в планировочной сцене.
    """

    try:
        # Введение в демонстрацию.
        print("")
        print("----------------------------------------------------------")
        print("Welcome to the MoveIt MoveGroup Python Interface Tutorial")
        print("----------------------------------------------------------")
        print("Press Ctrl-D to exit at any time")
        print("")

        # Ожидание пользователя для начала демонстрации.
        input(
            "============ Press `Enter` to begin the tutorial by setting up the moveit_commander ..."
        )

        # Создание объекта класса MoveGroupPythonInterfaceTutorial.
        # Этот объект содержит все методы управления роботом и сценой.
        tutorial = MoveGroupPythonInterfaceTutorial()

        # Демонстрация движения к целевому состоянию суставов.
        input(
            "============ Press `Enter` to execute a movement using a joint state goal ..."
        )
        tutorial.go_to_joint_state()

        # Демонстрация движения к целевой позе в пространстве.
        input("============ Press `Enter` to execute a movement using a pose goal ...")
        tutorial.go_to_pose_goal()

        # Планирование и отображение декартовой траектории.
        input("============ Press `Enter` to plan and display a Cartesian path ...")
        cartesian_plan, fraction = tutorial.plan_cartesian_path()

        # Отображение сохраненной траектории в Rviz.
        input(
            "============ Press `Enter` to display a saved trajectory (this will replay the Cartesian path)  ..."
        )
        tutorial.display_trajectory(cartesian_plan)

        # Выполнение сохраненной траектории.
        input("============ Press `Enter` to execute a saved path ...")
        tutorial.execute_plan(cartesian_plan)

        # Добавление объекта (коробки) в планировочную сцену.
        input("============ Press `Enter` to add a box to the planning scene ...")
        tutorial.add_box()

        # Прикрепление объекта к роботу.
        input("============ Press `Enter` to attach a Box to the Panda robot ...")
        tutorial.attach_box()

        # Планирование и выполнение траектории с прикрепленным объектом.
        input(
            "============ Press `Enter` to plan and execute a path with an attached collision object ..."
        )
        cartesian_plan, fraction = tutorial.plan_cartesian_path(scale=-1)
        tutorial.execute_plan(cartesian_plan)

        # Отсоединение объекта от робота.
        input("============ Press `Enter` to detach the box from the Panda robot ...")
        tutorial.detach_box()

        # Удаление объекта из планировочной сцены.
        input(
            "============ Press `Enter` to remove the box from the planning scene ..."
        )
        tutorial.remove_box()

        # Завершение демонстрации.
        print("============ Python tutorial demo complete!")

    # Обработка исключений при прерывании работы ROS.
    except rospy.ROSInterruptException:
        return

    # Обработка прерывания программы с клавиатуры.
    except KeyboardInterrupt:
        return


# Проверяем, что модуль запускается как основная программа.
if __name__ == "__main__":
    main()
